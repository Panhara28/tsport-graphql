"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _dataloader = _interopRequireDefault(require("dataloader"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class BaseRepository {
  constructor(tx) {
    _defineProperty(this, "tableName", void 0);

    _defineProperty(this, "idColumnName", "id");

    _defineProperty(this, "tx", void 0);

    _defineProperty(this, "selectColumns", "*");

    this.tx = tx;
  }

  async all() {
    return await this.tx(this.tableName).select(...this.selectColumns);
  }

  async findById(id) {
    return this.tx.table(this.tableName).where({
      [this.idColumnName]: id
    }).first(...this.selectColumns);
  }

  async findByCustomFieldIds(column, ids) {
    return await this.tx.table(this.tableName).whereIn(column, ids).select(...this.selectColumns);
  }

  async findByIdForUpdate(id) {
    return this.tx.table(this.tableName).where({
      [this.idColumnName]: id
    }).forUpdate().first(...this.selectColumns);
  }

  async findByIds(ids, preserveOrder = false, columns = "*") {
    if (ids.length === 0) return [];
    const rows = await this.tx.table(this.tableName).whereIn(this.idColumnName, ids).select(columns || this.selectColumns);
    if (!preserveOrder) return rows;
    return ids.map(id => {
      const item = rows.find(x => x[this.idColumnName] === id);
      if (!item) return null;
      return item;
    });
  }

  async findOne(condition) {
    return this.tx.table(this.tableName).where(condition).first();
  }

  async insert(value) {
    const result = await this.tx.table(this.tableName).insert(value);
    return result[0];
  }

  async insertMany(values) {
    await this.tx.table(this.tableName).insert(values);
  }

  async update(id, value) {
    return this.tx.table(this.tableName).where({
      [this.idColumnName]: id
    }).update(value);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  static map(...arg) {
    throw "Not implemented yet";
  }

  static createAutoGeneratedLoader(ctx) {
    return new _dataloader.default(async keys => {
      const repo = new this(ctx.knex.default);

      if (this.map) {
        const row = await repo.findByIds(keys, true);
        return row.map(x => this.map(x, ctx));
      }
    });
  }

  static createAutoGeneratedLoaderWithManyFromColumn(ctx, fieldName) {
    return new _dataloader.default(async keys => {
      const repo = new this(ctx.knex.default);

      if (this.map) {
        const rows = await repo.findByCustomFieldIds(fieldName, keys);
        return keys.map(key => rows.filter(row => row[fieldName] === key).map(x => this.map(x, ctx)));
      }
    });
  }

}

exports.default = BaseRepository;