import DataLoader from "dataloader";
import * as Knex from "knex";
import ContextType from "../graphql/ContextType";

type ValueOrKnexRaw<T> = {
  [P in keyof T]: T[P] | Knex.Raw;
};

export default class BaseRepository<T, K = number> {
  protected tableName: string;
  protected idColumnName = "id";
  protected tx: Knex;
  protected selectColumns: string | string[] = "*";

  constructor(tx: Knex) {
    this.tx = tx;
  }

  async all(): Promise<T[]> {
    return await this.tx(this.tableName).select<unknown>(...this.selectColumns);
  }

  async findById(id: K): Promise<T> {
    return this.tx
      .table(this.tableName)
      .where({ [this.idColumnName]: id })
      .first<unknown>(...this.selectColumns);
  }

  async findByCustomFieldIds(column: string, ids: number[]): Promise<T[]> {
    return await this.tx
      .table(this.tableName)
      .whereIn(column, ids)
      .select<unknown>(...this.selectColumns);
  }

  async findByIdForUpdate(id: K): Promise<T> {
    return this.tx
      .table(this.tableName)
      .where({ [this.idColumnName]: id })
      .forUpdate()
      .first<unknown>(...this.selectColumns);
  }

  async findByIds(
    ids: number[],
    preserveOrder = false,
    columns: string | string[] = "*"
  ): Promise<T[]> {
    if (ids.length === 0) return [];

    const rows: T[] = (await this.tx
      .table(this.tableName)
      .whereIn(this.idColumnName, ids)
      .select(columns || this.selectColumns)) as T[];

    if (!preserveOrder) return rows;

    return ids.map((id) => {
      const item = rows.find((x) => x[this.idColumnName] === id);
      if (!item) return null;
      return item;
    });
  }

  async findOne(condition: T): Promise<T> {
    return this.tx.table(this.tableName).where(condition).first();
  }

  async insert(value: T): Promise<number> {
    const result = await this.tx.table(this.tableName).insert(value);
    return result[0];
  }

  async insertMany(values: T[]) {
    await this.tx.table(this.tableName).insert(values);
  }

  async update(id: K, value: ValueOrKnexRaw<T>): Promise<boolean> {
    return this.tx
      .table(this.tableName)
      .where({ [this.idColumnName]: id })
      .update(value);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static map(...arg) {
    throw "Not implemented yet";
  }

  static createAutoGeneratedLoader<G>(ctx: ContextType): DataLoader<number, G> {
    return new DataLoader<number, G>(async (keys: number[]) => {
      const repo = new this(ctx.knex.default);
      if (this.map) {
        const row = await repo.findByIds(keys, true);
        return row.map((x) => this.map(x, ctx) as unknown as G);
      }
    });
  }

  static createAutoGeneratedLoaderWithManyFromColumn<G>(
    ctx: ContextType,
    fieldName: string
  ): DataLoader<number, G[]> {
    return new DataLoader<number, G[]>(async (keys: number[]) => {
      const repo = new this(ctx.knex.default);
      if (this.map) {
        const rows = await repo.findByCustomFieldIds(fieldName, keys);
        return keys.map((key) =>
          rows
            .filter((row) => row[fieldName] === key)
            .map((x) => this.map(x, ctx) as unknown as G)
        );
      }
    });
  }
}
